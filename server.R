server <- function(input, output, session) {
  ## NOTE: params is checked for being NA to protect against the default
  ## case_when in an observe. It does nothing otherwise.
  updateNumericInputs <- function(params, session = getDefaultReactiveDomain()) {
    if (!all(is.na(params))) {
      mapply(
        function(inputId, value) {
          updateNumericInput(session, inputId, value = value)
        },
        value = params,
        inputId = names(params)
      )
    }
  }

  ## Predicate certain input validation rules on a model being active.
  `%conditionWidgetRulesOnModel%` <-
    function(ruleList, modelName, env = parent.frame()) {
      with(list(validator = InputValidator$new(), serverEnv = env), {
        ## Create a name for the validator and assign it into the server
        ## environment outside the function this with call exists in.
        assign(paste0("validator", modelName), validator, serverEnv)
        ## Condition upon the namesake model being selected.
        addRuleListToValidator(
          validator,
          ruleList,
          # This might not work...
          \() input$modelSelect == modelName
        )
        return(validator)
      })
    }

  ## Add all of the rules generated by rule function factories to a validator,
  ## and optionally condition those rules on condition.
  addRuleListToValidator <- function(validator, ruleList, condition = NULL) {
    validator$condition(condition)

    mapply(
      function(inputId, ruleVector) {
        ## inputId is intentionally recycled while adding the rules in
        ## ruleVector.
        mapply(validator$add_rule, inputId, ruleVector)
      },
      names(ruleList),
      ruleList
    )

    ## Enable the validator and return it invisibly.
    validator$enable()
    invisible(validator)
  }

  globalValidator <- addRuleListToValidator(
    InputValidator$new(),
    list(
      ## Vital statistics
      muBirth = c(sv_between(0, 0.1)),
      muDeath = c(sv_between(0, 0.1)),
      population = c(sv_gt(0)),
      susceptible = c(sv_gt(0)),
      exposed = c(sv_gte(0)),
      infected = c(sv_gte(0)),
      recovered = c(sv_gte(0)),
      dead = c(sv_gte(0)),
      ## NOTE: the limit might need to change.
      ## replicates = c(sv_integer(), sv_between(0, 100, c(FALSE, TRUE))),
      replicates = c(sv_integer(), sv_gt(0)),
      timesteps = c(sv_numeric(), sv_gt(0))
    )
  )

  reactive({
    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 5))
    ) %conditionWidgetRulesOnModel% "SIR" |>
      globalValidator$add_validator()

    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 5))
    ) %conditionWidgetRulesOnModel% "SIRS" |>
      globalValidator$add_validator()


    list(
      beta = c(sv_between(0, 0.5)),
      gamma = c(sv_between(0, 0.5)),
      delta = c(sv_between(0, 0.5))
    ) %conditionWidgetRulesOnModel% "SIRD" |>
      globalValidator$add_validator()


    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 3)),
      sigma = c(sv_between(0, 0.5))
    ) %conditionWidgetRulesOnModel% "SEIR" |>
      globalValidator$add_validator()


    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 3)),
      sigma = c(sv_between(0, 0.5)),
      xi = c(sv_between(0, 0.5))
    ) %conditionWidgetRulesOnModel% "SEIRS" |>
      globalValidator$add_validator()


    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 3)),
      sigma = c(sv_between(0, 0.5)),
      delta = c(sv_between(0, 0.5))
    ) %conditionWidgetRulesOnModel% "SEIRD" |>
      globalValidator$add_validator()
  })

  ## FIXME: when a value is set by the user, and then Vital Dynamics is
  ## disabled, the effective value should be zero to control how the models
  ## operate. If Vital Dynamics is re-enabled the previous value should be
  ## restored unless the user has reset all values using the reset action
  ## button. NOTE: use a simple variable to store the previous value; that
  ## variable must also be reset to zero when the entire application is reset so
  ## that the "historical" value the user entered is forgotten.
  observeEvent(input$muValue, {
    with(list(session = getDefaultReactiveDomain()), {
      updateNumericInput(session, "muBirth", value = 0)
      updateNumericInput(session, "muDeath", value = 0)
    })
  })

  ## NOTE: when the user changes between total and pseudo mass action, vital
  ## dynamics are disabled and various widget values are reset. ## MAYBE:
  ## discuss whether this is intuitive to the user; will they expect certain
  ## changes, as a consequence of theory, or are we being intrusive and changing
  ## values on them. They may have spent quite a bit of time setting parameters
  ## and variables before selecting the mass action formulation they wanted.
  observeEvent(input$massActionSelect, {
    ## Disable vital dynamics whenever the mass action type changes.
    updateCheckboxInput(getDefaultReactiveDomain(), "muValue", value = FALSE)

    with(list(
      model = input$modelSelect,
      massAction = input$massActionSelect,
      stochastic = input$stochasticSelect
    ), {
      ## TODO: filter a dataframe on the values above and then update numeric
      ## inputs.
      updateNumericInputs(
        if (massAction == 1 && model == "SIR") {
          list(
            beta = 0.4,
            gamma = 0.04,
            population = 1000,
            susceptible = 997,
            infected = 3,
            recovered = 0,
            timesteps = 25
          )
        } else if (massAction == 0 && model == "SIR") {
          list(
            beta = 0.001,
            gamma = 0.1,
            population = 500,
            susceptible = 499,
            infected = 1,
            recovered = 0,
            timesteps = 50
          )
        } else if (massAction == 1 && model == "SIRD") {
          list(
            beta = 0.4,
            gamma = 0.04,
            delta = 0.05,
            population = 1000,
            susceptible = 997,
            infected = 3,
            recovered = 0,
            timesteps = 25
          )
        } else if (massAction == 0 && model == "SIRD") {
          list(
            beta = 0.001,
            gamma = 0.1,
            delta = 0.05,
            population = 500,
            susceptible = 499,
            infected = 1,
            recovered = 0,
            timesteps = 50
          )
        } else if (massAction == 1 && model == "SEIRD") {
          list(
            beta = 0.35,
            gamma = 0.1429,
            sigma = 0.0476,
            population = 500,
            susceptible = 499,
            exposed = 0,
            infected = 1,
            recovered = 0,
            timesteps = 20
          )
        } else if (massAction == 0 && model == "SEIR") {
          list(
            beta = 0.5,
            gamma = 0.5,
            sigma = 0.1,
            population = 53,
            susceptible = 50,
            exposed = 3,
            infected = 0,
            recovered = 0,
            timesteps = 25
          )
        } else if (massAction == 1 && model == "SEIRD") {
          list(
            beta = 0.35,
            gamma = 0.1429,
            sigma = 0.0476,
            delta = 0.05,
            population = 500,
            susceptible = 499,
            exposed = 0,
            infected = 1,
            recovered = 0,
            timesteps = 20
          )
        } else if (massAction == 0 && model == "SEIRD") {
          list(
            beta = 0.5,
            gamma = 0.5,
            sigma = 0.1,
            delta = 0.05,
            population = 53,
            susceptible = 50,
            exposed = 3,
            infected = 0,
            recovered = 0,
            timesteps = 50
          )
        } else if (stochastic == 1 && model == "SIR") {
          list(
            stochasticModelVariableNumberOfReplicates = 50,
            ## FIXME: these values are being set as the label for the widget
            ## somehow.
            beta = 0.00178,
            gamma = 2.73,
            population = 1000,
            susceptible = 990,
            infected = 10,
            recovered = 0,
            timesteps = 10
          )
        }
      )
    })
  })

  ## Toggle the visibility of the outputPanel based on the user's interactions
  ## with the "go" actionButton.
  observeEvent(input$go, {
    show("outputPanel")
    ## TODO: ignore any warnings about unused arguments; they're irrelevant.
    ## We simply provide all possible input widgets and the function consumes
    ## whatever it actually uses.
    R.utils::doCall.default(.ignoreUnusedArguments = TRUE,
      ## The solve and render functions are defined in files named like
      ## `input$modelSelect_solve.R' in the R subfolder.
      paste0("solveAndRender", input$modelSelect),
      args = list(
        beta = input$beta, gamma = input$gamma,
        delta = input$delta, xi = input$xi, sigma = input$sigma,
        ## TODO: these need to be defined in the UI and their appearance
        ## conditioned upon the models.
        ##
        ## alpha = input$alpha,
        ## ay = input$ay, bee = input$bee,
        ## AY = input$AY, BEE = input$BEE

        ## Variables
        ## vaccinated = input$vaccinated,
        susceptible = input$susceptible,
        infected = input$infected,
        recovered = input$recovered,
        dead = input$dead,
        exposed = input$exposed,
        population = input$population))

    ## The LaTeX is rendered dynamically based upon the selected model.
    ## Rendering occurs every time the GO action button is pressed. This will
    ## allow more flexibility later on, if needed.
    output$modelLaTeX <-
      renderUI(renderModelLaTeX(input$modelSelect, input$muValue))
  })

  ## TODO: resetting the application should set the widget values to those which
  ## are defined for the model in the spreadsheet.
  observeEvent(input$resetAll, {
    hide("outputPanel")
    hide("modelConfiguration")
    hide("actionButtons")
    with(list(session = getDefaultReactiveDomain()), {
      updatePickerInput(session, "modelSelect", selected = "")
      updateRadioButtons(session, "massActionSelect", selected = 0)
      updateRadioButtons(session, "stochasticSelect", selected = 0)
      updateCheckboxInput(session, "muValue", value = FALSE) # Vital Dynamics
      updateNumericInput(session, "timesteps", value = 100)
    })
  })

  ## Whenever the model selection changes (whether the parameters and variables
  ## are set manually or taken from pre-defined models), the widget values
  ## throughout the application are updated as appropriate.
  observeEvent(input$modelSelect, {
    with(list(
      model = input$modelSelect,
      stochastic = input$stochasticSelect,
      vital = input$muValue,
      session = getDefaultReactiveDomain()
    ), {
      ## If no model is selected, hide the model configuration and action buttons.
      if (input$modelSelect %in% "") {
        hide("modelConfiguration")
        hide("actionButtons")
      } else {
        show("modelConfiguration")
        show("actionButtons")
      }

      hide("outputPanel")

      updateRadioButtons(session, "massActionSelect", selected = 0)
      updateRadioButtons(session, "stochasticSelect", selected = 0)

      ## TODO: refactor the application to use a more descriptive variable name:
      ## `vitalDynamicsSelect', perhaps.
      updateCheckboxInput(session, "muValue", value = FALSE) # Vital Dynamics

      ## TODO: the function must handle NAs appropriately, such that a widget
      ## is hidden when the value is NA rather than set to an invalid state.
      updateNumericInputs(as.list(filter(defaultParameterValues,
                                         modelType == model,
                                         stochastic == stochastic)))

      if(grepl("SI", model, ignore.case = TRUE)) {
        updateNumericInput(session, "beta", r"[$Rate of infection (\beta)$]")
        updateNumericInput(session, "gamma", r"[$Rate of recovery (\gamma)$]")
      } else if(grepl("SEI", model, ignore.case = TRUE)) {
        updateNumericInput(session, "beta", r"[$Rate of exposure (\beta)$]")
        updateNumericInput(session, "gamma", r"[$Rate of infection (\gamma)$]")
      }
    })
  })
}
