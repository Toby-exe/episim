server <- function(input, output, session) {
  # Initialize simple-caching and global variables.
  # cachedBirthRate <- 0
  # cachedDeathRate <- 0


# Functions, such as the solveAndRender dispatcher -----------------------------
  solveAndRender <- function(model, modelArguments) {
    modellingFunctions <- mget(paste0(c("solve", "plot", "plotPhasePlane"), model),
         envir = environment(solveSIR),
         mode = "function")

    modelSolver <- modellingFunctions[[1]]
    modelPlotter <- modellingFunctions[[2]]
    modelPhasePlanePlotter <- modellingFunctions[[3]]

    expr <- substitute({
      modelResults <- doCall.default(.fcn = modelSolver,
                                     args = modelArguments,
                                     .ignoreUnusedArguments = TRUE)
      output$modelPlot <- renderPlot(modelPlotter(modelResults))
      output$modelPhasePlane <- renderPlot(modelPhasePlanePlotter(modelResults))
      output$modelSummaryTable <- renderTable(modelResults[, 1:6])
    })

    eval.parent(expr)
  }

  ## NOTE: params is checked for being NA to protect against the default
  ## case_when in an observe. It does nothing otherwise.
  updateNumericInputs <- function(params, session = getDefaultReactiveDomain()) {
    if (!all(is.na(params))) {
      mapply(
        function(inputId, value) {
          updateNumericInput(session, inputId, value = value)
        },
        value = params,
        inputId = names(params)
      )
    }
  }

  ## Predicate certain input validation rules on a model being active.
  `%conditionWidgetRulesOnModel%` <-
    function(ruleList, modelName, env = parent.frame()) {
      with(list(validator = InputValidator$new(), serverEnv = env), {
        ## Create a name for the validator and assign it into the server
        ## environment outside the function this with call exists in.
        assign(paste0("validator", modelName), validator, serverEnv)
        ## Condition upon the namesake model being selected.
        addRuleListToValidator(
          validator,
          ruleList,
          # This might not work...
          \() input$modelSelect == modelName
        )
        return(validator)
      })
    }

  ## Add all of the rules generated by rule function factories to a validator,
  ## and optionally condition those rules on condition.
  addRuleListToValidator <- function(validator, ruleList, condition = NULL) {
    validator$condition(condition)

    mapply(
      function(inputId, ruleVector) {
        ## inputId is intentionally recycled while adding the rules in
        ## ruleVector.
        mapply(validator$add_rule, inputId, ruleVector)
        validator$add_rule(inputId, sv_required())
      },
      names(ruleList),
      ruleList
    )

    ## Enable the validator and return it invisibly.
    validator$enable()
    invisible(validator)
  }

  ## NOTE: all inputs have the required rule automatically added.
  globalValidator <- addRuleListToValidator(
    InputValidator$new(),
    list(
      ## Vital statistics
      muBirth = c(sv_between(0, 0.1)),
      muDeath = c(sv_between(0, 0.1)),

      population = c(sv_integer(), sv_gt(0)), # GT, not GTE
      susceptible = c(sv_integer(), sv_gt(0)), # GT, not GTE
      ## NOTE: unused at the moment. There are no models with a vaccinated compartment.
      vaccinated = c(sv_integer(), sv_gte(0)), # These are all GTE
      exposed = c(sv_integer(), sv_gte(0)),
      infected = c(sv_integer(), sv_gte(0)), # FIXME: this might need GT
      recovered = c(sv_integer(), sv_gte(0)),
      dead = c(sv_integer(), sv_gte(0)),

      ## NOTE: the number of replicates might need to be limited.
      ## replicates = c(sv_integer(), sv_between(0, 100, c(FALSE, TRUE))),
      replicates = c(sv_integer(), sv_gt(0)),
      timesteps = c(sv_numeric(), sv_gt(0)),

      ## Global rules for parameters
      beta = c(sv_gt(0)),
      gamma = c(sv_gt(0))
    )
  )

  ## NOTE: all inputs have the required rule automatically added.
  reactive({
    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 1))
    ) %conditionWidgetRulesOnModel% "SIR" |>
      globalValidator$add_validator()

    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 1)),
      xi = c(sv_between(0, 1))
    ) %conditionWidgetRulesOnModel% "SIRS" |>
      globalValidator$add_validator()


    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 1)),
      delta = c(sv_between(0, 1))
    ) %conditionWidgetRulesOnModel% "SIRD" |>
      globalValidator$add_validator()


    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 1)),
      sigma = c(sv_between(0, 1))
    ) %conditionWidgetRulesOnModel% "SEIR" |>
      globalValidator$add_validator()


    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 1)),
      sigma = c(sv_between(0, 1)),
      xi = c(sv_between(0, 1))
    ) %conditionWidgetRulesOnModel% "SEIRS" |>
      globalValidator$add_validator()


    list(
      beta = c(sv_between(0, 1)),
      gamma = c(sv_between(0, 1)),
      sigma = c(sv_between(0, 1)),
      delta = c(sv_between(0, 1))
    ) %conditionWidgetRulesOnModel% "SEIRD" |>
      globalValidator$add_validator()
  })

  ## FIXME: this is a naive way of disabling vital dynamics. A preferable
  ## alternative is to add the term to or remove it from the equations, rather
  ## than making the term equal to zero.
  observeEvent(input$muValue, {
    if (input$muValue == FALSE) {
      updateNumericInput(session, "muBirth", value = 0)
      updateNumericInput(session, "muDeath", value = 0)
    }
  })

# GO: show outputPanel; call modelling function; render LaTeX. ------------
  ## Toggle the visibility of the outputPanel based on the user's interactions
  ## with the "go" actionButton.
  observeEvent(input$go, {
    show("outputPanel")

    solveAndRender(input$modelSelect, reactiveValuesToList(input))
    output$modelLaTeX <- renderUI(renderModelLaTeX(input$modelSelect,
                                                   input$muValue, input$massActionSelect))

  })


# RESET: hide outputPanel; modelConfiguration; actionButtons; rese --------
  ## TODO: resetting the application should set the widget values to those which
  ## are defined for the model in the spreadsheet.
  observeEvent(input$resetAll, {
    hide("outputPanel")
    hide("modelConfiguration")
    hide("actionButtons")
    with(list(session = getDefaultReactiveDomain()), {
      updatePickerInput(session, "modelSelect", selected = "")
      updateRadioButtons(session, "massActionSelect", selected = 0)
      updateRadioButtons(session, "stochasticSelect", selected = 0)

      ## Disable vital dynamics and cause the cached birth and death rates to be
      ## forgotten through dependency invalidation.
      updateCheckboxInput(session, "muValue", value = FALSE)
      ## FIXME: see the related fixme in the observable for muValue's change
      updateNumericInput(session, "muBirth", value = 0)
      updateNumericInput(session, "muDeath", value = 0)

      updateNumericInput(session, "timesteps", value = 100)
    })
  })


# MODEL SELECT: update numeric inputs to model defaults on change. --------
  ## Whenever the model selection changes (whether the parameters and variables
  ## are set manually or taken from pre-defined models), the widget values
  ## throughout the application are updated as appropriate.
  observeEvent(input$modelSelect, {
    with(list(
      model = input$modelSelect,
      stochastic = input$stochasticSelect,
      vital = input$muValue,
      session = getDefaultReactiveDomain()
    ), {
      ## If no model is selected, hide the model configuration and action buttons.
      if (input$modelSelect %in% "") {
        hide("modelConfiguration")
        hide("actionButtons")
      } else {
        show("modelConfiguration")
        show("actionButtons")
      }

      hide("outputPanel")

      updateRadioButtons(session, "massActionSelect", selected = 0)
      updateRadioButtons(session, "stochasticSelect", selected = 0)

      ## TODO: refactor the application to use a more descriptive variable name:
      ## `vitalDynamicsSelect', perhaps.
      updateCheckboxInput(session, "muValue", value = FALSE) # Vital Dynamics

      ## TODO: the function must handle NAs appropriately, such that a widget
      ## is hidden when the value is NA rather than set to an invalid state.
      updateNumericInputs(as.list(filter(defaultParameterValues,
                                         modelType == model,
                                         stochastic == stochastic)))

      ## NOTE: this triggers the anonymous function in
      ## www/whenModelSelectChangesTypesetLaTeX.js to be called, typesetting the
      ## updated labels.
      if(grepl("SI", model, ignore.case = TRUE)) {
        updateNumericInput(session, "beta", r"[Rate of infection ($ \beta $)]")
        updateNumericInput(session, "gamma", r"[Rate of recovery ($ \gamma $)]")
      } else if(grepl("SEI", model, ignore.case = TRUE)) {
        updateNumericInput(session, "beta", r"[Rate of exposure ($ \beta $)]")
        updateNumericInput(session, "gamma", r"[Rate of infection ($ \gamma $)]")
      }
    })
  })

  ## FIXME: the input is not being validated properly, because the global
  ## validator is returning the incorrect value and "go" is never being enabled.
  ## observeEvent(input, {
  ##   if(globalValidator$is_valid()) {
  ##     enable("go")
  ##   } else {
  ##     disable("go")
  ##   }
  ## })
}
